# 设计目标

前面我们列举了业界比较流行的一些微服务框架，一个研发框架的选型不仅要考察框架本身，也要考虑其后续的维护，以及团队技术栈和未来技术的演进方向。我们在前面介绍了如何对框架进行选型，也提到了在团队必要情况下也可以考虑自研一个框架。

自研一个微服务框架时，首先要明确的就是设计目标：要实现一个怎样的框架？

我们进行框架选型时，脑海中其实列了一个checklist，对现有框架进行层层检查，最后整理出一个表格，可以看到A框架满足那些条目，B框架满足哪些条目，C框架又满足哪些条目，等等。这是对比选择同类产品时所常用的一种方法，如以Spring Boot、Go Micro、BRpc为例：

|  | Spring Boot | Go Micro | BRpc |
| :--- | :--- | :--- | :--- |
| multi languages | N | N | N |
| RPC support | Y | Y | Y |
| naming service | Y | Y | Y |
| logging | Y | Y | Y |
| tracing | Y | Y | Y |
| ... | ... | ... | ... |

其实，这里的框架选型时的checklist也未尝不是我们的一个设计目标，它也是设计目标中的一部分。

在明确微服务框架的设计目标时，通常要给出一个checklist要更细致一些的定义，微服务框架整体也是由部分构成，各个部分通过某种协作关系构成一个整体。要想清晰的列举出这里应该包含哪些部分，以及各部分之间的协作关系，就必须要清晰地罗列出我们需要的功能性指标，以及其他非功能性指标。

gorpc101系列，是以系统性介绍一个微服务框架的研发为目的，并非以超越某个流行的rpc框架为目的。我们的设计目标相对来说也比较清晰：

* 功能完整：框架提供相对完整的能力，并提供默认实现，开箱即用；
  * 支持tcp/udp/unix/http等transport，支持扩展传输类型；
  * 支持rpc通信方式，并提供灵活的rpc控制能力，如指定超时时间等；
  * 支持服务注册发现，支持扩展服务注册发现方式，如借助consul、zipkin、etcd等；
  * 支持codec，支持扩展协议类型；
  * 支持logging，支持扩展目的输出类型，如console、file、syslog等类型；
  * 支持metrics，支持扩展目的输出类型，如prometheus等类型；
  * 支持tracing，支持扩展目的输出类型，如zipkin、jaeger等类型；
  * 支持filter，提供常用filters，支持扩展filter来丰富能力，如rpc耗时上报；
  * 支持config，支持扩展不同输入来源，如ini、toml、yaml文件以及配置中心；
  * 支持audit，提供常见认证方式，支持扩展；
  * 支持broker，支持消息发布、接受，支持扩展以支持不同消息队列；
  * 支持admin，支持对运行时服务进行管理，如修改运行时配置、查看运行时状态；
* 插件化：框架提供核心能力，允许插件化定制各组件，以更好适应不同场景；
* 高性能：框架需具备业界领先或近似的处理性能；
* 可测试：框架、基于框架开发的服务必须可测试、方便测试；
* 易使用：基于框架开发微服务时应该很简单、省时省力省心；
* go开发：使用go语言开发该微服务框架，主要面向go后端开发者；

总结一下，微服务框架gorpc要遵循 **“小而美”** 的设计，是基于go开发的主要面向后台开发的微服务框架，旨在提升后台开发效率，让大家摆脱各种琐碎的细节，转而更加专注于服务质量本身。**Simple but Powerful**，提供业界领先或近似的高性能处理，也支持服务注册发现、rpc通信等相对完整的能力，并支持灵活地扩展，也支持便捷地开发环境设置和服务模板生成、测试代码生成等，让研发变得更高效！


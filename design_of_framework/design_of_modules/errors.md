# errors

## 模块设计：errors

为什么要提供一个errors模块呢？当然是为了更方便地错误处理。go标准库提供了package errors用来定义一些错误，这些错误可以用于在函数调用过程中传递、返回、执行比较判断等等，而且自go1.13开始吧也支持了errors.Wrap/Unwrap/Is等操作允许对error进行包装/解开/判断等能力，对于常规错误处理而言，是绰绰有余了。

但是对于一个服务而言，其内部可观测到的错误，除了业务逻辑错误，还有底层框架观测到的错误。希望有能力能对这两种类型的错误进行区分，以方便框架、业务方做相应的处理。

比如以转账为例，一次转账RPC调用，网络超时是框架错误，而转出余额不足则是逻辑错误。针对两种类型的错误可以执行不同的错误处理逻辑，网络超时可以采用重试，余额不足则可以短信通知用户失败。

比如以转账为例，一次转账RPC调用，网络超时是框架错误，而转出余额不足则是逻辑错误。针对两种类型的错误可以执行不同的错误处理逻辑，网络超时可以采用重试，余额不足则可以短信通知用户失败。

如何区分是哪种类型的错误呢？

如何区分是哪种类型的错误呢？

* 假如沿用go的使用习惯，可能会定义一个`var errFramework = errors.New("framework error")`基础，凡是框架类错误都通过`fmt.Errorf("%w: %s",  errFramework, err)`来声明，后续判断是否是框架错误的时候可以通过`errors.Is(err, errFramework)`来判断。通过这种方式来区分框架、业务错误已经足够了，但是继续考虑下RPC框架中涉及到C/S之间的通信，当server返回一个框架错误信息给client，序列化的时候没有把当前err包含的errFramework包含进去或者即便包含了client端也不不方便识别，这种实现就又变得是问题。
* 另一种方式就是定义一个Error类型，其中包含错误码、错误信息、错误类型，设计如下图所示。Error实现了error接口，其Error\(\)方法用于展示错误码、描述、类型的格式化字符串。Error的类型主要包含框架错误、业务逻辑错误。
* 假如沿用go的使用习惯，可能会定义一个`var errFramework = errors.New("framework error")`基础，凡是框架类错误都通过`fmt.Errorf("%w: %s",  errFramework, err)`来声明，后续判断是否是框架错误的时候可以通过`errors.Is(err, errFramework)`来判断。通过这种方式来区分框架、业务错误已经足够了，但是继续考虑下RPC框架中涉及到C/S之间的通信，当server返回一个框架错误信息给client，序列化的时候没有把当前err包含的errFramework包含进去或者即便包含了client端也不不方便识别，这种实现就又变得是问题。
* 另一种方式就是定义一个Error类型，其中包含错误码、错误信息、错误类型，设计如下图所示。Error实现了error接口，其Error\(\)方法用于展示错误码、描述、类型的格式化字符串。Error的类型主要包含框架错误、业务逻辑错误。这种方式在RPC通信时也比较好处理，直接把Error中的部分或者全部字段纳入序列化流程，序列化完成后、编码成响应包、发送即可，就解决了上面这点提到的问题。

综合上述方式考虑，我们建议采用方法二，在此基础上进行模块化设计，设计如下所示：

![errors&#x6A21;&#x5757;&#x8BBE;&#x8BA1;](../../.gitbook/assets/image%20%282%29.png)

设计实现errors的时候，还应该考虑到这里的框架errors是否需要导出，哪些应该导出，各个错误对应的错误码、错误描述、类型要统一整理好。

为了方便使用方查询、比较框架errors，最好能将errors统一整理。比如像这样：

```text
var (
    errXXX = newError(1000, ".........", ErrorTypeFramework)
    errYYY = newError(1001, ".........", ErrorTypBusiness
    
    ErrZZZ = NewError(1002, ".........")
)
```

这也是解决问题的一种思路吧，也是该教程中推荐的做法。


---
description: >-
  在前一节中，介绍了大致的软件服务架构的演变过程及原因，从单体架构、分布式架构、SOA架构，到如今流行的微服务架构。每一种架构模式，都存在历史的局限性，它可能较好地解决了当时软件领域存在的一些问题，但是放在今天却并不一定适用。无需感叹“被淘汰”，因为它得益于“发展”，想想当今互联网如何颠覆、便利了我们的生活。本节将重点介绍下大行其道的微服务架构的优势以及所面临的挑战。
---

# 微服务架构优势及挑战

## 微服务架构

微服务（Microservices），又称为微服务架构。它是一种架构模式，指导我们如何将一个应用程序合理分解成一系列的服务，并通过服务之间的协作来实现期望的功能。

![&#x5FAE;&#x670D;&#x52A1;&#x67B6;&#x6784;](../.gitbook/assets/image%20%2814%29.png)

这里的分解出的微服务应当满足：

* 高度的可维护性、可测试性
* 松耦合
* 独立部署
* 通过组合实现业务功能
* 可由不同团队负责

微服务架构，使得一个庞大复杂的应用也可以实现快速迭代、频繁和可靠的交付，它也赋予了开发团队来革新技术栈的选择能力。微服务架构，将敏捷（Agile）、模块化（Modular）推向了一个新的高度。

## 微服务模式语言

微服务架构并不是软件领域的银弹，它也存在很多的问题。而且，当选择了使用微服务架构之后，会引入一些必须要面对、要解决的问题，否则，没什么收益反受其累。

软件领域令人着迷的一点就是，知识的沉淀分享。模式（Patterns）正是业界先驱、开发者们经历了实践检验后所沉淀下来的一些方法论，我们可以学习、实践这些模式以轻松应对不同的场景，没必要自己踩过一波雷再自己总结出血的教训。

微服务架构模式语言，其实指的是一系列微服务架构设计开发中常采用的一些方法论（模式）的集合。

![&#x5FAE;&#x670D;&#x52A1;&#x67B6;&#x6784;&#x6A21;&#x5F0F;&#x8BED;&#x8A00;](../.gitbook/assets/image%20%2813%29.png)

模式语言主要想达到两个目标：

* 帮助决策目标场景是否适合采用微服务架构；
* 帮助在业务中成功地应用微服务架构；

传统的单体架构模式对不少应用程序来说，仍然一个不错的选择。当然对于规模很大、很复杂的应用程序或软件系统，单体架构确实存在一些限制、问题，微服务架构会是一种更好的选择。而在使用、落地微服务架构的过程中，面向模式的软件架构设计（Patterns Oriented Architecture Design），应该是每一位开发者所掌握的。

## 微服务的优势

我们很多后端开发者的主要工作，就是开发一些服务端的企业级应用程序。

### 开发服务端程序

从这个背景触发，假设我们现在要开发这样一个服务端企业级应用程序，它要支持不同类型的客户端访问，包括桌面、移动端浏览器及移动端native程序。服务端程序要暴露一个API给3种不同的客户端来访问，服务端程序也可能会通过RPC、Web Services或者消息broker来与其他程序进行集成。服务端收到客户端HTTP请求执行对应的业务逻辑、访问数据库、和其他系统交换消息、返回请求处理的结果。服务端程序内部也有不同的一些组件来完成特定的功能。

那现在要解决的问题已经明确了，我们还需要考量下几个不同维度的指标。

### “受力分析”

_物理学中对一个物体或系统进行受力分析，为了判断出合力的方向、大小，必须对过程中受到的各个分作用力进行分析，称之为受力分析。通过受力分析可以明确物体或系统的运动趋势。_

在软件架构设计中，也有类似于物理学受力分析的过程。当我们明确了要解决的问题之后，就需要重新审视所关心的各个指标（称之为force），我们的架构是否能满足所有指标，还是要在不同指标之间做权衡。实际情况是，几乎所有的选择都是在权衡利弊。

我们有哪些需要关心的指标呢？

* 服务端程序的开发，会由一个团队的开发者共同完成；
* 新的团队成员，需要能够快速产出；
* 服务端程序本身，应该易于理解、修改；
* 必须能够实现持续集成；
* 必须能够分布式多实例部署，来满足可伸缩性、可用性要求；
* 允许集成新兴技术（如框架、编程语言等等）；
* 其他；

有些forces是跟团队技术栈、代码可维护性、研发效能相关的，有些是与运营质量相关的，也有些是与新兴技术相关的，这才是一个大公司中所面临的真实研发场景。几乎总是不可避免地要在上述forces中进行权衡、取舍。

### 传统架构

如果我们采用传统的单体架构的话，所有的程序都放在一个项目中，部署的时候打包成一个程序，并且支持多机分布式部署，并通过负载均衡来提高系统并发处理能力。

单体架构的好处是，易于开发、测试、部署、伸缩。但是也存在明显的问题，参考我们上面列出的forces。

* 如果业务场景越来越多，程序规模越来越大，了解程序的整体逻辑会比较困难，新人难以快速上手。团队规模也越来越大，可能还是不同技术栈的，如何保证大家产出代码的质量，难以发挥不同技术栈开发人员的优势。最终会导致整体研发效率下降、研发质量下降。
* IDE负载过高，随着程序规模扩大，IDE建立索引、编译构建等等都会出现严重的效率下降的问题，最终也会拖慢研发效率。
* Web容器过载，假如我们是采用Java Web开发，最终达成一个WAR包形式，程序规模变大势必会导致Web容器启动过慢，开发人员开发、测试效率也会下降，降低研发效率；
* 持续集成困难，可能修改了一个组件的代码，但是单体架构却要完整部署整个应用。慢只是其中一方面，如果修改后的组件有问题还会影响到整个应用本身，如导致应用无法启动，影响到团队其他成员开发、测试等。最终会导致大家不愿意去频繁地更新，但是对UI开发来说频繁更新应该是很常见的。
* 应用伸缩困难，这种单体架构只能朝一个维度来伸缩，就是你可以多部署几台机器多运行几个实例，来提供更高的并发处理能力。但是数据层面的伸缩却不理想，因为所有的程序实例都访问相同的、所有的数据，实例内部的cache不会很有效，可能增加了内存占用的同时还引发更多的IO操作。还有，就是程序内部不同组件不能更细粒度地去伸缩，比如有的模块是计算密集型的，有的模块是IO密集型的，这些组件对需要的资源类型、数量都不同的，单纯增加运行实例数量并不能实现很好地伸缩。
* 团队协作困难，当程序规模大了之后，自然而然地我们想对应用按照层次、功能进行分类，以交由不同的团队负责，比如UI展示层、逻辑层、数据层、各种组件适配等，但是因为是单体架构，怎么拆分让不同团队独立开发呢？很难实现。这样也会导致整体研发效率下降，而且要保证单体架构功能的完整性，需要协调多个团队的研发任务、进度，协作花费的时间也会大大增加。
* 被捆绑在了特定的技术栈上，难以发挥团队不同技术栈开发人员的优势，也难以将业界新兴技术引入进来。比如一开始选择了使用Java开发，但是后面发现go支持协程，同步编码异步高性能运行，就是发现go再香这个时候也难以在单体架构的程序中采用了，除非重写整个应用程序，但是工作中以业务为先，这几乎是不可能的。

### 微服务架构



## 微服务的挑战





## 参考文献

1. What are microservices, [https://microservices.io/](https://microservices.io/)
2. The pattern language is your guide, [https://microservices.io/](https://microservices.io/)
3. F.Buschmann, R.Meunier, H.Rohnert, Pattern-Oriented Software Architecture
4. 
